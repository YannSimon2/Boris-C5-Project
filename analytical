# Analytical simulation of particle motion in plasma wakefield
# This code models the transverse motion of a particle in a plasma bubble wakefield

import numpy as np
import matplotlib
matplotlib.use('TkAgg')  # Set backend for plot display
import matplotlib.pyplot as plt
from scipy.constants import c, e, m_e, epsilon_0  # Physical constants
from numba import jit
from matplotlib.animation import FuncAnimation
import scipy.integrate as spi

# === Physical Parameters ===
# Plasma wave parameters
a_0_analytic = 5 
v_p_analytic = 0.99                                    # Phase velocity of plasma wave (99% speed of light)
beta_p_analytic = v_p_analytic                                 # Normalized phase velocity
gamma_p_analytic = 1/np.sqrt(1-beta_p_analytic**2)              # Lorentz factor of plasma wave                                
phi_analytic = np.pi/2 - 2*gamma_p_analytic                     # Phase parameter
phiprime_analytic = 0 
r_b_analytic = 2*np.sqrt(a_0_analytic)                                 # Bubble radius in meters (200 microns)
                                      # Normalized vector potential (laser strength)
ksi_i_analytic = -r_b_analytic                           # Initial position

gamma_d_analytic = (gamma_p_analytic**2)*(ksi_i_analytic**2)/2  
t_d_analytic = -2*gamma_p_analytic**2*ksi_i_analytic                   # Dephasing time scale
zeta_i_analytic = r_b_analytic/4


# Time array for simulation (normalized)
t_ini_analytic = t_d_analytic/1000                            # Start time (small fraction of dephasing time)
t_analytic = np.linspace(t_ini_analytic,t_d_analytic,1000)         # Time from small fraction to half dephasing time

# === Function Definitions ===

def gamma_0_analytic(t):
    """
    Time-dependent Lorentz factor
    Models how particle energy changes due to dephasing with plasma wave
    """
    tau = (t-t_d_analytic)/t_d_analytic                         # Normalized time parameter
    return gamma_d_analytic*(1-tau**2)                 # Parabolic energy profile

C_analytic = zeta_i_analytic*(gamma_0_analytic(t_ini_analytic))**(1/4)/np.cos(phiprime_analytic)                                      # Amplitude constant

def zeta_beta_analytic(t):
    """
    Amplitude of transverse oscillation
    Depends on particle energy (weaker particles oscillate more)
    """
    return C_analytic*gamma_0_analytic(t)**(-1/4)              # Amplitude scales as gamma^(-1/4)

def omega_beta_analytic(t):
    """
    Time-dependent betatron frequency
    Frequency of transverse oscillations in the plasma bubble
    """
    return 1/np.sqrt(2*gamma_0_analytic(t))     # Frequency depends on energy

def zeta_analytic(t):
    """
    Transverse position in x-direction
    Calculated by integrating the oscillatory motion
    """
    return np.array([zeta_beta_analytic(t[i])*np.cos(spi.quad(omega_beta_analytic,0,t[i])[0] + phiprime_analytic) for i in range(len(t))])

def zeta_y_analytic(t):
    """
    Transverse position in y-direction
    Currently identical to x-direction (could be modified for different phases)
    """
    return np.array([zeta_beta_analytic(t[i])*np.cos(spi.quad(omega_beta_analytic,0,t[i])[0] + phiprime_analytic) for i in range(len(t))])
# === 2D Plotting ===
# Create subplots showing energy evolution and transverse motion

plt.figure(figsize=(8, 4))



plt.plot(t_analytic, 100*gamma_p_analytic + gamma_0_analytic(t_analytic))
plt.xlabel(r'$\omega_p t$',fontsize=14)
plt.ylabel(r'$\gamma_z(t)$',fontsize=14)
plt.grid()
plt.title('Londitudinal Lorentz Factor vs Time (analytical)',fontsize=16)
plt.tight_layout()
plt.show()

plt.figure(figsize=(8, 4))
zeta_vals_plot_analytic = zeta_analytic(t_analytic)

plt.plot(t_analytic, zeta_vals_plot_analytic)
plt.xlabel(r'$\omega_p t$',fontsize=14)
plt.ylabel(r'$k_p x$',fontsize=14)
plt.grid()
plt.title('Transverse Motion in Wakefield (analytical)',fontsize=16)

plt.tight_layout()
plt.show()

# === 3D Trajectory Calculation ===
# Calculate longitudinal motion by integrating acceleration from energy changes

fig_analytic = plt.figure(figsize=(10, 8))
ax_analytic = fig_analytic.add_subplot(111, projection='3d')

# Calculate z position (longitudinal direction)
# Assuming initial z=0 and integrating acceleration from gamma_0
z_analytic = np.zeros_like(t_analytic) + ksi_i_analytic - v_p_analytic*t_ini_analytic                         # Initialize z positions
dt_analytic = t_analytic[1] - t_analytic[0]                             # Time step
v_z_analytic = np.sqrt(1-1/((100*gamma_p_analytic + gamma_0_analytic(t_analytic))**2))  # longitudinal velocity

for i in range(1, len(t_analytic)):
                  # Update velocity
    z_analytic[i] = z_analytic[i-1] + v_z_analytic[i] * dt_analytic               # Update position

# Get transverse positions
zeta_vals_analytic = zeta_analytic(t_analytic)                         # x-direction transverse motion
# zeta_y_vals_analytic = zeta_y_analytic(t_analytic)                     # y-direction transverse motion
zeta_y_vals_analytic = np.zeros_like(zeta_vals_analytic)  # Set y-motion to zero for simplicity



# Plot 3D trajectory with normalized coordinates
ax_analytic.plot(zeta_vals_analytic, zeta_y_vals_analytic, z_analytic, 'b-', linewidth=2, label='Particle path')
ax_analytic.scatter(zeta_vals_analytic[0], zeta_y_vals_analytic[0], z_analytic[0], color='green', s=100, label='Start')
ax_analytic.scatter(zeta_vals_analytic[-1], zeta_y_vals_analytic[-1], z_analytic[-1], color='red', s=100, label='End')

ax_analytic.set_xlabel(r'$k_px$')
ax_analytic.set_ylabel(r'$k_py$')
ax_analytic.set_zlabel(r'$k_pz$')
ax_analytic.set_title('3D Particle Trajectory in Plasma Wakefield')
ax_analytic.legend()
plt.show(block=True)

# === Animated 3D Trajectory ===
# Create real-time visualization of particle motion through the plasma

fig_anim_analytic = plt.figure(figsize=(8, 6))
ax_anim_analytic = fig_anim_analytic.add_subplot(111, projection='3d')

# Set up the plot limits based on calculated trajectory (normalized)
ax_anim_analytic.set_xlim([min(zeta_vals_analytic), max(zeta_vals_analytic)])
ax_anim_analytic.set_ylim([min(zeta_y_vals_analytic), max(zeta_y_vals_analytic)])
ax_anim_analytic.set_zlim([min(z_analytic), max(z_analytic)])
ax_anim_analytic.set_xlabel(r'$k_px$')
ax_anim_analytic.set_ylabel(r'$k_py$')
ax_anim_analytic.set_zlabel(r'$k_pz$')
ax_anim_analytic.set_title('Animated 3D Particle Trajectory in Plasma Wakefield')

# Initialize empty line objects for animation
line_analytic, = ax_anim_analytic.plot([], [], [], 'b-', linewidth=2, label='Trajectory')
point_analytic, = ax_anim_analytic.plot([], [], [], 'ro', markersize=8, label='Current position')

# Add text for time counter
time_text_analytic = ax_anim_analytic.text2D(0.05, 0.90, '', transform=ax_anim_analytic.transAxes, 
                          bbox=dict(boxstyle="round,pad=0.5", facecolor="white", alpha=0.9),
                          fontsize=11, weight='bold', verticalalignment='top')

def animate_analytic(frame):
    """
    Animation function called for each frame
    Updates the trajectory line and current position marker
    """
    # Update trajectory up to current frame (shows trail) - normalized coordinates
    line_analytic.set_data_3d(zeta_vals_analytic[:frame+1], zeta_y_vals_analytic[:frame+1], z_analytic[:frame+1])
    
    # Update current position point (red dot)
    if frame < len(t_analytic):
        point_analytic.set_data_3d([zeta_vals_analytic[frame]], [zeta_y_vals_analytic[frame]], [z_analytic[frame]])
        
        # Update time counter - show normalized time
        current_time_norm_analytic = t_analytic[frame]
        time_text_analytic.set_text(f'Time: {current_time_norm_analytic:.2f} s\nFrame: {frame+1}/{len(t_analytic)}')
    
    return line_analytic, point_analytic, time_text_analytic

# Create animation object
# frames=len(t_analytic): number of animation frames
# interval=1: delay between frames in milliseconds (very fast)
# blit=True: optimization for smoother animation
# repeat=True: loop animation continuously
anim_analytic = FuncAnimation(fig_anim_analytic, animate_analytic, frames=len(t_analytic), interval=1, blit=True, repeat=True)

plt.show(block=True)

